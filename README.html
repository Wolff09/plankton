<!doctype html>
<html lang="en">
<head>
	<!-- Required meta tags -->
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

	<!-- Bootstrap CSS -->
	<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css" integrity="sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO" crossorigin="anonymous">
	
	<!-- Font Awesome CSS -->
	<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css" integrity="sha384-mzrmE5qonljUremFsqc01SB46JvROS7bZs3IO2EmfFsd15uHvIt+Y8vEf7N7fWAU" crossorigin="anonymous">
	
	<!-- highlight.js -->
	<!-- <link rel="stylesheet" href="highlight.default.css">
	<script src="highlight.pack.js"></script>
	<script>hljs.initHighlightingOnLoad();</script> -->
	
	<title>plankton</title>

	<style type="text/css">
		header {
			padding: .75rem;
		}
		header .logos a {
			display: inline-block;
		}
		header .logos a:hover {
			opacity: .7;
			transform: scale(1.05, 1.05);
		}

		div.mt-4 h1 {
			border-bottom: 2px solid #e83e8c;
			border-left: 20px /*solid #e83e8c;
			padding-left: 5px;*/
		}
		div.mt-4 h1 span.index {
			display: inline-block;
			width: 1em;
			text-align: center;
			background-color: #e83e8c;
			color: white;
		}
		div.mt-4 h3,h4 {
			border-bottom: 1px dashed #e83e8c;
		}

		table.experiments .fas, table.experiments .far {
			width: 1.25em;
		}
		table.experiments .fa-check, .experiments.fa-check {
			color: #33DD33;
		}
		table.experiments .fa-times, .experiments.fa-times {
			color: #DD3333;
		}
		table.experiments .fa-clock, .experiments.fa-clock {
			color: #EACF33;
		}

		kbd {
			text-transform: uppercase;
			padding: .1rem .2rem;
			background-color: lightgray;
			color: black;
			/*background: none;
			padding: none;
			text-transform: uppercase;
			color: #e83e8c;*/
		}
		kbd.head {
			padding: 0 .2rem;
		}

		pre {
			padding-top: .5rem;
			padding-bottom: .5rem;
		}
		pre.tight {
			padding-top: 0;
			padding-bottom: 0;
			margin-bottom: 0;
		}
		pre.files {
			line-height: 1.1rem;
		}
		pre code.color {
			color: #e83e8c;
		}

		.code-link {
			color: #e83e8c;
		}

		.tooltip-inner {
			/*max-width: 400px;*/
			max-width: 25rem;
		}
		/*.tooltip-inner i {
			font-weight: 600;
		}*/
		span.ref-full::before, span.ref-year::before, .ref-item-id::before {
			content: "[";
		}
		span.ref-full::after, span.ref-year::after, .ref-item-id::after {
			content: "]";
		}
		.ref-item {
			margin-top: .35rem;
		}
		.ref-item-id, .ref-item-id::before, .ref-item-id::after {
			font-weight: bold;
		}
		.ref-item-paper {
			font-style: italic;
		}
	</style>
</head>
<body>
	<br>
	<div class="container clearfix">
		<!-- ********************************************************************************** -->
		<!-- ************************************** PAPER ************************************* -->
		<!-- ********************************************************************************** -->
		<div class="jumbotron">
			<h1 style="font-size: 2.75rem;">
				Embedding Hindsight Reasoning in Separation Logic
			</h1>
			<h3>
				<small>
					ANONYMOUS AUTHOR(S)
				</small>
			</h3>
			<p class="lead text-justify mb-2">
				<strong>Paper Abstract.</strong>
				Automatically proving linearizability of concurrent data structures remains a key challenge for verification. We present temporal interpolation as a new proof principle to guide automated proof search using hindsight arguments within concurrent separation logic. Temporal interpolation offers an easy-to-automate alternative to prophecy variables and has the advantage of structuring proofs into easy-to-discharge hypotheses. Additionally, we advance hindsight theory by integrating it into a program logic, bringing formal rigor and complementary proof machinery. We substantiate the usefulness of temporal interpolation by implementing it in a tool and using it to automatically verify the Logical Ordering tree. The proof is challenging due to future-dependent linearization points and complex structure overlays. It is the first formal proof of this data structure. Interestingly, our formalization revealed an unknown bug and an existing informal proof as erroneous.
			</p>
			<p class="lead text-justify mb-2">
				<strong>Artifact Abstract.</strong>
				We use our implementation, an extension of the <kbd>plankton</kbd> tool, to (1) automatically verify the Logical Ordering tree, and (2) compare our extension with the original version of <kbd>plankton</kbd> in terms of performance and proof capabilities.
			</p>
			<p class="lead text-justify mb-2">
				<strong>Artifact Repository.</strong>
				<a href="https://zenodo.org/record/7686111">https://zenodo.org/record/7686111</a>
			</p>
		</div>
		<br>


		<!-- ********************************************************************************** -->
		<!-- ********************************* GETTING STARTED ******************************** -->
		<!-- ********************************************************************************** -->

		<div class="mt-4">
			<h1 id="started"><span class="index">A</span> Getting Started</h1>
			<p>
				To get the artifact up and running, you may choose between a prebuilt docker image or a docker build script.
				There are prebuilt images for <strong>x86</strong> and <strong>arm64</strong> (Apple Silicon).
				The build script is universal.
			</p>

			<!-- ******************************** REPO STRUCTURE ******************************** -->
			<h4>Repository Structure</h4>
			<p>
				The <a href="https://zenodo.org/record/7686111">Zenodo repository</a> for this artifact is structured as follows:
			</p>
			<pre class="bg-light border files">
  https://zenodo.org/record/7686111
  ├── plankton_x86.tar     # prebuilt docker image
  ├── plankton_arm64.tar   # prebuilt docker image
  ├── plankton.zip         # source files + docker build script
  └── README.html          # this document</pre>
			<p>
				You do not need to download the entire repository!
				See your preferred method of installation below for more details.
			</p>

			<!-- ********************************* DOCKER IMAGE ********************************* -->
			<h4>Install Option 1: Docker image (x86, arm64)</h4>
			<ol>
				<li>
					Install <a href="https://www.docker.com/">Docker</a>.
				</li>
				<li>
					<p>
						Import the the docker image directly from the <a href="https://zenodo.org/record/7686111">Zenodo repository</a> using <b>one</b> of the following commands that fits you hardware architecture:
					</p>
					<pre class="bg-light border"><code class="bash">  docker import https://zenodo.org/record/7686111/plankton_arm64.tar  # arm64 including Apple Silicon
  docker import https://zenodo.org/record/7686111/plankton_x86.tar    # or x86</code></pre>
						If you do not know the architecture of you system, run the command <code>arch</code> in a shell.
						It may print an alias of <code>x86</code>, e.g.: <code>x86-64</code>, <code>x86_64</code>, <code>amd64</code>, or even <code>i386</code> (MacOS only).
						Beware that choosing the wrong architecture results in Docker <i>emulating</i> the artifact: this renders the artifact functional, but comes with substantial performance penalties. <b>TODO: check if thats true</b>
						<br>
						If you already downloaded the docker image, do <code class="bash">docker import path/to/plankton_&lt;your_arch&gt;.tar</code>.
				</li>
				<li>
					Done! <a href="#chkinstall">Check the installation</a> now.
				</li>
			</ol>

			<!-- ********************************* DOCKER SCRIPT ******************************** -->
			<h4>Install Option 3: Docker build script (universal)</h4>
			<ol>
				<li>
					Install <a href="https://www.docker.com/">Docker</a>.
				</li>
				<li>
					Download the source files <code>plankton.zip</code> from the <a href="https://zenodo.org/record/7686111">Zenodo repository</a>.
				</li>
				<li>
					Unzip <code>plankton.zip</code>.
					This results in a folder called <code>plankton</code>.
					We assume that this folder's location is <code>path/to/plankton</code>.
				</li>
				<li>
					Create a docker instance for the artifact:
					<pre class="bg-light border"><code class="bash">  cd path/to/plankton
  docker build . -t plankton</code></pre>
				</li>
				<li>
					Done! <a href="#chkinstall">Check the installation</a> now.
				</li>
			</ol>

			<!-- ************************************* CHECK ************************************ -->
			<h4 id="chkinstall">Check Installation</h4>
			<p>
				To run the installed artifact, use an interactive docker shell:
			</p>
			<pre class="bg-light border"><code class="bash">  docker run -it plankton</code></pre>
			<p>
				This will take you to folder <code>/artifact/plankton/</code> within the installed artifact.
				From there, run this:
			</p>
			<pre class="bg-light border"><code class="bash">  ./plankton examples/check.pl</code></pre>
			<p>
				This command is expected to finish without errors within a few seconds.
				At the end of the output, you should see something like this:
			</p>
			<pre class="bg-light border">
  #
  # Verdict for '"Installation Check"':
  #   is linearizable: YES
  #   time taken (ms): 7903
  #
  
  @gist[../examples/check.pl]=1,7903;</pre>
			<p>
				The important part here is that <kbd>plankton</kbd> successfully establishes linearizability.
				The time it takes to do so may vary depending on your system.
				You can ignore the <code>@gist</code> line, it is just an easy-to-parse summary.
			</p>
			<p>
				If the check succeeded, you are ready for the full evaluation! You can fast-forward to the <a href="#eval">step-by-step instructions</a>.
			</p>

			<!-- ****************************** ARTIFACT STRUCTURE ****************************** -->
			<h4>Artifact Structure</h4>
			<p>
				All installation methods from above yield an artifact (docker image) with the following structure:
			</p>
			<pre class="bg-light border files">
  /artifact/
  ├── plankton/
  │   ├── examples/
  │   ├── source/
  │   │   └── ...
  │   ├── plankton
  │   ├── benchmark.sh
  │   └── prettyprint.py
  ├── plankton-debug/
  │   └── ...
  └── z3/
      └── ...</pre>
			<p>
				The <code>/artifact/plankton/</code> folder contains an installation of <kbd>plankton</kbd>.
				In there is the executable <code>plankton</code>, a shell script <code>benchmark.sh</code> for the <a href="#eval">step-by-step instructions</a>, a Python script <code>prettyprint.py</code> used by <code>benchmark.sh</code>, a folder <code>examples/</code> with linearizable data structure implementations, and a folder <code>source/</code> containing the source files from which the binary was build.
			</p>
			<p>
				The folder <code>/artifact/plankton-debug/</code> is a mirror of <code>/artifact/plankton/</code> but was compiled with debug flags.
				This makes the output much more verbose compared to the release version in <code>/artifact/plankton/</code>.
				The debug version, for instance, will print separation logic assertion for the pre and post conditions for every proof step.
				The folder <code>/artifact/z3/</code> contains the source and build files for <strong>Z3</strong> (<a target="new" href="https://github.com/Z3Prover/z3/releases/tag/z3-4.8.7">v4.8.7</a>).
			</p>
		</div>
		<br>


		<!-- ********************************************************************************** -->
		<!-- ********************************** STEP BY STEP ********************************** -->
		<!-- ********************************************************************************** -->

		<div class="mt-4">
			<h1 id="eval"><span class="index">B</span> Step-by-Step Instructions</h1>
			<p>
				We show how to reproduce the experiments from the submitted version of our paper (<a href="#claim1">Claim 1</a>).
				Moreover, we show how to produce additional experimental results (<a href="#claim2">Claim 2</a>) that we will add to the camera-ready version, as per the reviewers' request.
			</p>
			<div class="alert alert-info">
				If you do not have the artifact running anymore, fire it up: <code>docker run -it plankton</code>
			</div>

			<!-- ************************************ LO TREE *********************************** -->
			<h4 id="claim1">Claim 1: Verifying the LO-tree</h4>
			<p>
				<strong>Central claim:</strong>
				our new version of <kbd>plankton</kbd> automatically verifies a version of the <i>LO-tree</i> <span class="ref-full">DrachslerVY14</span> where the maintenance operations are replaced by <i>most general stubs</i>.
				The code of the implementation can be found in the file <code>examples/LO_tree.pl</code>
			</p>
			<p>
				To repeat the verification, run the following command:
			</p>
			<pre class="bg-light border"><code class="bash">  ./plankton examples/LO_tree.pl --new</code></pre>
			<p>
				The flag <code class="bash">--new</code> instructs <kbd>plankton</kbd> to use our novel analysis (i.e. temporal interpolation).
				To have <kbd>plankton</kbd> perform the original analysis devised by <span class="ref-full">MeyerWW22</span>, use the flag <code class="bash">--old</code>.
			</p>
			<p>
				Note that the verification of the LO-tree may take a while:
				about 40m on an Apple M1 Pro or about 60m on an Intel i5-8600K.
				<b>SAME AS IN PAPER?</b>
				<!-- While <kbd>plankton</kbd> is running, it will output the current status. -->
				Once finished, <kbd>plankton</kbd> will print the verdict and time taken, e.g.:
			</p>
			<pre class="bg-light border">
  ...
  [iter-2] Fixed-point reached.
  Proof generation was successful!
  ...
  
  #
  # Verdict for '"Logical Ordering Tree (most general tree overlay)"':
  #   is linearizable: YES
  #   time taken (ms): 2483975
  #</pre>
  		<p>
  			You may wish run the original version of <kbd>plankton</kbd> from <span class="ref-full">MeyerWW22</span>. Do so as follows:
  		</p>
			<pre class="bg-light border"><code class="bash">  ./plankton examples/LO_tree.pl --old</code></pre>
			<p>
				You will see an error along the following lines, stating that verification failed:
			</p>
			<pre class="bg-light border">
  ...
  [iter-1][fun-contains] Checking linearizability of function 'contains'...

  ERROR: Could not establish linearizability for function 'contains'.</pre>

  		<p><i>This concludes reproducing the claim.</i></p>
			<p>
				While <kbd>plankton</kbd> is constructing a proof, its output informs you of the current status.
				This includes (i) the iteration of the overall fixed point that is being computed, (ii) the function that is being analyzed, (iii) the command being handled, (iv) loops for which a loop invariant is computed, and (v) macros that are invoked.
				For an example, consider this output snippet:
			</p>
			<pre class="bg-light border">
  ...
  [iter-1][fun-contains][macro-traverse][loop-2] Post for 'c_1 = y_1->left; '. (1) 
  [iter-1][fun-contains][macro-traverse][loop-2] Applying interference. (1) 
  [iter-1][fun-contains][macro-traverse][loop-2] Post for 'assume(k_1 >= y_1->key); '. (1) 
  [iter-1][fun-contains][macro-traverse][loop-2] Applying interference. (1) 
  ...</pre>
			<p>
				Here <kbd>plankton</kbd> is (i) in the 1st iteration for (ii) function <code>contains</code>, handling (iii) commands <code>c_1 = y_1->left</code> followed by <code>assume(k_1 >= y_1->key)</code> during the (iv) 2nd iteration of a fixed point for finding a loop invariant in macro (v) <code>traverse</code>.
				After each command, <kbd>plankton</kbd> makes the resulting proof state (a separation logic assertion) stable under interference (cf. end of Section 3 in the paper).
				The numbers in parentheses at the end of each line indicate the number of distinct <i>proof branches</i> that reach this location; the branches are interpreted disjunctively.
			</p>

			<!-- ********************************** COMPARISON ********************************** -->
			<h4 id="claim2">Claim 2: Performance Comparison</h4>
			<p>
				<strong>Central claim</strong>:
				our new version of <kbd>plankton</kbd> can verify the same benchmarks as the original version from <span class="ref-full">MeyerWW22</span> with just a mild slow down (factor 2-4 slower).
			</p>
			<p>The benchmark set of <span class="ref-full">MeyerWW22</span> consists of the following implementations:
			</p>
			<ul>
				<li>
					<i>Fine-grained set</i> <span class="ref-full">HerlihyS08</span>:
					<br>
					<code>examples/FineSet.pl</code>
				</li>
				<li>
					<i>Lazy set</i> <span class="ref-full">HellerHLMSS05</span>:
					<br>
					<code>examples/LazySet.pl</code>
				</li>
				<li>
					<i>FEMRS tree (no maintenance)</i> <span class="ref-full">FeldmanEMRS18</span>:
					<br>
					<code>examples/FemrsTreeNoMaintenance.pl</code>
				</li>
				<li>
					<i>Vechev&Yahav's DCAS set</i> and <i>CAS set</i> <span class="ref-full">VechevY08</span>:
					<br>
					<code>examples/VechevYahavDCAS.pl</code> and <code>examples/VechevYahavCAS.pl</code>
				</li>
				<li>
					<i>ORVYY's set</i> <span class="ref-full">OHearnRVYY10</span>:
					<br>
					<code>examples/ORVYY.pl</code>
				</li>
				<li>
					<i>Michael's set</i> <span class="ref-full">Michael02</span> and a variation:
					<br>
					<code>examples/Michael.pl</code> and <code>examples/MichaelWaitFreeSearch.pl</code>
				</li>
				<li>
					<i>Harris' set</i> <span class="ref-full">Harris01</span> and a variation:
					<br>
					<code>examples/Harris.pl</code> and <code>examples/HarrisWaitFreeSearch.pl</code>
				</li>
			</ul>

			<p>
				To analyze the benchmark set with both versions of <kbd>plankton</kbd>, run the following script (this may take several hours, see below):
			</p>
			<pre class="bg-light border"><code class="bash"> ./benchmark.sh</code></pre>
			<p>
				You can specify the number of times each benchmark should be repeated to average the runtime: <code class="bash">./benchmark.sh 5</code>, for instance, performs 5 repetitions.
				By default, the script will execute every benchmark once.
			</p>
			<div class="alert alert-warning">
				We are aware of an issue where the <code>benchmark.sh</code> scrip will report failure, however, running <kbd>plankton</kbd> directly in the shell results in successful verification.
				The issue is due to Z3 spontaneously misbehaving when piping output to a file.
				We believe the pipe triggers a <a href="https://github.com/Z3Prover/z3/issues/5179">known bug in Z3</a>.
			</div>
			<p>
				After all benchmarks are run, the expected output on an Apple M1 is the following table:
			</p>
			<pre class="bg-light border">
  [][][][] ?????????????????</pre>
			<p>
				For comparison, the expected output on an Intel i5-8600K is this:
			</p>
			<pre class="bg-light border">
  [][][][] ?????????????????</pre>
			<p>
				Here, we are concerned only with the last column of the table, which is the verification verdict and the overall time it took.
				We stress that absolute running times vary from system to system.
				The thing to note is that both the <code>old</code> and <code>new</code> versions verify the same implementations and that the <code>new</code> version is at most 4 times slower.
			</p>
			<p>
				The meaning of the columns is as follows <span class="ref-full">MeyerWW22</span>:
			</p>
			<ul>
				<li><i>Program: </i>the name of the example program,</li>
				<li><i>Version:</i> <code>old</code> refers to the original version due to <span class="ref-full">MeyerWW22</span> and <code>new</code> refers to our extension,</li>
				<li><i>Iter:</i> number of iterations until interferences (effects) are saturated,</li>
				<li><i>Eff:</i> number of interference effects,</li>
				<li><i>Cand:</i> number of future candidates,</li>
				<li><i>Com:</i> percentage of overall runtime spent for handling atomic commands,</li>
				<li><i>Fut:</i> percentage of overall runtime spent for future reasoning,</li>
				<li><i>Hist:</i> percentage of overall runtime spent for history reasoning,</li>
				<li><i>Join:</i> percentage of overall runtime spent for the join operation,</li>
				<li><i>Inter:</i> percentage of overall runtime spent for applying interferences, and</li>
				<li><i>Linearizability:</i> linearizability verdict and time in seconds to generate it (i.e. a proof thereof).</li>
			</ul>

			<p>
				<i>This concludes artifact evaluation.</i>
			</p>
		</div>
		<br>


		<!-- ********************************************************************************** -->
		<!-- ************************************ DEEP DIVE *********************************** -->
		<!-- ********************************************************************************** -->

		<div class="mt-4">
			<h1 id="deepdive"><span class="index">C</span> Deep Dive</h1>
			<p>
				<strong>The following is not part of artifact evaluation.</strong>
				We provide additional information for the invested reader.
			</p>

			<!-- ******************************* BUILD FROM SOURCE ****************************** -->
			<h4>Build from Source</h4>
			<p>
				To compile this project you need <strong>CMake</strong> (>3.21), <strong>CLAN</strong> (>12.0), <strong>Java JRE</strong> (>1.6), and <strong>Z3</strong> (<a target="new" href="https://github.com/Z3Prover/z3/releases/tag/z3-4.8.7">v4.8.7</a>).
				Additionally, you may need the libraries <code>uuid</code>, <code>uuid-dev</code>, and <code>pkg-config</code>.
				Compilation with <strong>GCC</strong> and <strong>G++</strong> (>10.0) is also possible, but we recommend <strong>CLANG</strong>.
				To run the benchmarking script, you need <strong>Pyton 3</strong> (>3.5).
			</p>

			<h5>Z3 Version</h5>
			<p>
				For reproducing the results, it is paramount to use the correct Z3 version: <a target="new" href="https://github.com/Z3Prover/z3/releases/tag/z3-4.8.7">v4.8.7</a>.
				Versions >4.8.7 generally fail to run <a href="https://z3prover.github.io/api/html/classz3_1_1solver.html#a4322874cf842109514596806684cd4d7"><code>z3::solver::consequences()</code></a> for the combination of theories required (integers + quantifiers + free functions).
				If <a href="https://z3prover.github.io/api/html/classz3_1_1solver.html#a4322874cf842109514596806684cd4d7"><code>z3::solver::consequences()</code></a> fails, <kbd>plankton</kbd> issues a warning and uses a backup procedure relying on potentially many individual calls to <a href="https://z3prover.github.io/api/html/classz3_1_1solver.html#a65d4e25fe55aa280fa800b9611cd8c04"><code>z3::solver::check()</code></a>.
				The backup procedure tremendously decreases performance, hence increases the runtime.
			</p>

			<p>
				We recommend to compile Z3 with the same compiler as you compile <kbd>plankton</kbd> with.
			</p>

			<h5>Compilation</h5>
			<p>
				To build the project, download the source code <code>plankton.zip</code> from the <a href="https://zenodo.org/record/7686111">Zenodo repository</a>.
				Then, do the following
			</p>
			<pre class="bg-light border"><code class="bash">  cd path/to/plankton.zip
  unzip plankton-pldi.zip  # alternatively: tar -xvf plankton-pldi.zip
  mkdir build
  cd build
  CXX=/path/to/CXX-compiler cmake .. -DCMAKE_INSTALL_PREFIX=/path/to/installation
  CXX=/path/to/CXX-compiler make
  make install</code></pre>
			<p>
				This creates a folder <code>/path/to/installation/plankton</code> at the specified location.
				This folder contains all binaries, scripts, and examples needed to reproduce the evaluation from the paper.
			</p>
			<p>
				We recommend to use the <code>-DCMAKE_INSTALL_PREFIX</code> to specify a location where to install the tool.
				Omitting this flag will install the tool somewhere like <code>/usr/local/</code>.
				You can customize the folder that is appended to <code>/path/to/installation</code> by setting <code>-DINSTALL_FOLDER</code> appropriately in the cmake invocation.
			</p>

			<!-- ************************************* TOOL ************************************* -->
			<h4>The <kbd class="head">plankton</kbd> Tool</h4>
			<p>
				We briefly describe how to interact with <kbd>plankton</kbd>.
			</p>

			<h5>Basic Usage</h5>
			<p>
				You invoke <kbd>plankton</kbd> like so:
			</p>
			<pre class="bg-light border"><code class="">  ./plankton  [OPTION]  &lt;path_to_program&gt;</code></pre>
			<p>
				The flags/options and their arguments are listed in the following table (excerpt).
			</p>
			<table class="table border">
				<thead>
					<tr>
						<th scope="col">Flag / Argument</th>
						<th class="text-center" scope="col">Optional</th>
						<th class="text-center" scope="col">Default</th>
						<th scope="col">Description</th>
					</tr>
				</thead>
				<tbody>
					<tr>
						<td class="text-nowrap"><code> &lt;path_to_program&gt; </code></td>
						<td class="text-center">no</td>
						<td class="text-center">&mdash;</td>
						<td>
							Input program file to analyze.
							For examples, <i class="fas fa-link text-secondary"></i> <a class="text-secondary" href="#benchmarks-programs" class="">See Benchmark Programs</a>
						</td>
					</tr>
					<tr>
						<td class="text-nowrap"><code> --old</code></td>
						<td class="text-center">yes</td>
						<td class="text-center"><code>false</code></td>
						<td>Disables temporal interpolation during proof construction, performing hindsight reasoning as presented by <span class="ref-full">MeyerWW22</span>.</td>
					</tr>
					<tr>
						<td class="text-nowrap"><code> --new</code></td>
						<td class="text-center">yes</td>
						<td class="text-center"><code>false</code></td>
						<td>Enables temporal interpolation during proof construction, performing hindsight reasoning as presented in our paper.</td>
					</tr>
					<tr>
						<td class="text-nowrap"><code> --future</code></td>
						<td class="text-center">yes</td>
						<td class="text-center"><code>false</code></td>
						<td>Uses futures to handle unbounded footprints, i.e., updates where that have an effect (physically or ghost) on potentially unboundedly many nodes in the heap.</td>
					</tr>
					<tr>
						<td class="text-nowrap"><code> --no-spurious</code></td>
						<td class="text-center">yes</td>
						<td class="text-center"><code>false</code></td>
						<td>Instructs the internal rewrite engine to prevent desugared <code>CAS</code> commands  to fail spuriously.
							Note that the C++ standard explicitly allows <code>CAS</code> to fail spuriously.
						</td>
					</tr>
					<tr>
						<td class="text-nowrap"><code> --loopNoPostJoin</code></td>
						<td class="text-center">yes</td>
						<td class="text-center"><code>false</code></td>
						<td>Prevents proof construction to perform a <i>join</i> over the postannotations of loops. This increases the precision of proof.
						</td>
					</tr>
				</tbody>
			</table>
			<p>
				Besides the above, <code>--version</code> prints the tool's version, <code>-h</code> and <code>--help</code> print the full usage description.
			</p>

			<h4>Input Programs</h4>
			<p>
				<kbd>plankton</kbd> supports a simple C-style input language.
				Below you find an example program that showcases the required components and the most common constructs.
				(Note that the below example may not be linearizable.)
				For a list of all supported constructs, refer to the <a target="new" href="https://www.antlr.org/">ANTLR</a> parser definition in <code>/artifact/plankton/source/src/parser/Plankton.g4</code>.
			</p>

			<h5>Initialization</h5>
			<p>
				The first part of a program declares some structures and shared variables, like <code>Node</code> resp. <code>Head</code> in the example below.
				Additionally, there is a dedicated initializer <code>__init__</code> that is executed atomically once before execution begins.
				The <code>#name</code> option is optional.
			</p>
			<pre class="bg-light border"><code class="c">  #name "Program Name"
  
  struct Node {
      data_t val; // 'int' and 'data_t' are synonyms
      bool marked;
      Node* next;
  }
  
  Node* Head;
  
  void __init__() {
      Head = malloc;
      Head-&gt;next = NULL;
      Head-&gt;marked = false;
      Head-&gt;val = MIN; // there is also 'MAX'
  }</code></pre>

			<h5>Flow&amp;Node invariants</h5>
			<p>
				First, <code>@contains</code> defines a predicate characterizing the logical contents of a node.
				This predicate takes a pointer to the node and a value, and returns <code>true</code> iff the given value is considered logically contained in the given node.
				Second, <code>@outflow</code> defines a predicate characterizing the outflow of a node per pointer field, here <code>next</code>.
				Third, <code>@invariant</code> defines the node invariants of the program.
				There is a dedicated invariant for nodes in the <code>local</code> and the <code>shared</code> heap.
			</p>
			<pre class="bg-light border"><code class="c">  def @contains(Node* node, data_t key) {
      !node-&gt;marked && node-&gt;val == key
  }
  
  def @outflow[next](Node* node, data_t key) {
      !node-&gt;marked ==&gt; node-&gt;val &lt; key
  }
  
  def @invariant[local](Node* x) {
      x-&gt;_flow == 0
  }
  
  def @invariant[shared](Node* x) {
      Head != NULL
   && Head-&gt;val == MIN
   && !Head-&gt;marked
   && Head-&gt;_flow != 0
   && [MIN, MAX] in Head-&gt;_flow
   && x-&gt;val == MIN ==&gt; x == Head
  
   && !x-&gt;marked ==&gt; [x-&gt;val, MAX] in x-&gt;_flow
   && x-&gt;_flow != 0 ==&gt; [x-&gt;val, MAX] in x-&gt;_flow
  }</code></pre>

			<h5>Helpers/Macros</h5>
			<p>
				Helper functions allow code reuse across multiple API functions.
				Helpers are defined with the keyword <code>inline</code>.
				They may have an arbitrary return type, including <code>void</code>, <code>int</code>, <code>data_t</code> (treated as alias of <code>int</code>), <code>Node*</code> (or pointers to any other declared struct), and comma separated lists of types.
			</p>
			<p>
				For verification, one can think of helpers being inlined.
			</p>
			<pre class="bg-light border"><code class="c">  inline &lt;Node*, data_t&gt; locate(data_t key) {
      Node* curr;
      data_t k;
      bool mark;
  
      curr = Head;
      do {
          curr = curr-&gt;next;
          k = curr-&gt;val;
          mark = curr-&gt;marked;
      } while (k &lt; key || mark);
      return &lt;curr, k&gt;;
  }</code></pre>

			<h5>API functions</h5>
			<p>
				API functions are targeted by the verification process.
				They must have return type <code>bool</code> and take a single <code>data_t</code> or <code>int</code> as argument.
				The allowed names are <code>contains</code>, <code>add</code>, <code>insert</code>, <code>remove</code>, and <code>delete</code>.
				<kbd>plankton</kbd> derives the specification of API functions from their name.
			</p>
			<pre class="bg-light border"><code class="c">  bool contains(data_t key) {
      Node* curr;
      data_t k;
  
      &lt;curr, k&gt; = locate(key);
      return k == key;
  }
  
  bool add(data_t key) {
      entry = malloc;
      entry-&gt;val = key;
      entry-&gt;marked = false;
  
      while (true) {
          Node* entry, curr;
          data_t k;
          &lt;curr, k&gt; = locate(key);
  
          if (k == key) {
              return false;
  
          } else {
              atomic {
                  entry-&gt;next = curr-&gt;next;
                  curr-&gt;next = entry;
              }
              return true;
          }
      }
  }
  
  bool remove(data_t key) {
      while (true) {
          Node* curr;
          data_t k;
          &lt;curr, k&gt; = locate(key);
  
          next = curr-&gt;next;
          if (CAS(&lt;curr-&gt;val, curr-&gt;marked&gt;, &lt;k, false&gt;, &lt;k, true&gt;))
              return true;
      }
  }</code></pre>


			<!-- ******************************** IMPLEMENTATION ******************************** -->
			<h4>Notes on the Implementation</h4>
			<p>
				The following table links the techniques referred to in the paper to the implementation.
			</p>

			<table class="table">
				<thead>
					<tr>
						<th scope="col">Paper</th>
						<th scope="col">Implementation</th>
						<th scope="col">Description</th>
					</tr>
				</thead>
				<tbody>
					<!-- https://github.com/Wolff09/plankton/blob/PLDI22/ -->
					<tr>
						<td scope="row">Programs, Logics</td>
						<td>
							<a target="new" href="https://github.com/Wolff09/plankton/blob/PLDI22/include/programs/ast.hpp" class="code-link"><code class="text-nowrap">include/programs/ast.hpp</code></a>
							<br>
							<a target="new" href="https://github.com/Wolff09/plankton/blob/PLDI22/include/logics/ast.hpp" class="code-link"><code class="text-nowrap">include/logics/ast.hpp</code></a>
						</td>
						<td class=""> <!-- text-justify -->
							Abstract syntax tree for programs and the logics.
						</td>
					</tr>
					<tr>
						<td scope="row">Flows, Invariants</td>
						<td>
							<a target="new" href="https://github.com/Wolff09/plankton/blob/PLDI22/include/engine/config.hpp" class="code-link"><code class="text-nowrap">include/engine/config.hpp</code></a>
						</td>
						<td class=""> <!-- text-justify -->
							Configuration object that specifies the flow and the node invariants.
							Configuration objects are taken (parsed) from the input program.
							Currently, the flow is restricted to keyset flows.
						</td>
					</tr>
					<tr>
						<td scope="row">Program Simplification</td>
						<td>
							<a target="new" href="https://github.com/Wolff09/plankton/blob/PLDI22/src/parser/" class="code-link"><code class="text-nowrap">src/parser/*</code></a>
						</td>
						<td class=""> <!-- text-justify -->
							The parser supports a richer input language that is transformed into the one defined in <code class="text-nowrap">include/programs/ast.hpp</code>.
						</td>
					</tr>
					<tr>
						<td scope="row">Commands</td>
						<td>
							<a target="new" href="https://github.com/Wolff09/plankton/blob/PLDI22/src/engine/solver/post_*.cpp" class="code-link"><code class="text-nowrap">src/engine/solver/post_*.cpp</code></a>
						</td>
						<td class=""> <!-- text-justify -->
							Implementation of Rule <code>(COM-SEM)</code>.
							There are specialized implementations for assignments to variables (<code class="text-nowrap">post_assign_var.cpp</code>), assignments to memory cells (<code class="text-nowrap">post_assign_write.cpp</code>), assumptions (<code class="text-nowrap">post_assume.cpp</code>), and allocation (<code class="text-nowrap">post_malloc.cpp</code>).
						</td>
					</tr>
					<tr>
						<td scope="row">Loops</td>
						<td>
							<a target="new" href="https://github.com/Wolff09/plankton/blob/PLDI22/src/engine/proof/stmt.cpp" class="code-link"><code class="text-nowrap">src/engine/proof/stmt.cpp</code></a>
						</td>
						<td class=""> <!-- text-justify -->
							Implementation of Rule <code>(LOOP)</code>.
						</td>
					</tr>
					<tr>
						<td scope="row">Flow Graphs</td>
						<td>
							<a target="new" href="https://github.com/Wolff09/plankton/blob/PLDI22/include/engine/flowgraph.hpp" class="code-link"><code class="text-nowrap">include/engine/flowgraph.hpp</code></a>
							<br>
							<a target="new" href="https://github.com/Wolff09/plankton/blob/PLDI22/src/engine/flowgraph/make.hpp" class="code-link"><code class="text-nowrap">src/engine/flowgraph/make.hpp</code></a>
						</td>
						<td class=""> <!-- text-justify -->
							Definition and generation of flow graphs.
							Flow graphs are generated wrt. a memory assignment by taking a fixed, finite number of reachable nodes starting from the nodes participating in the assignment.
						</td>
					</tr>
					<tr>
						<td scope="row">Histories</td>
						<td>
							<a target="new" href="https://github.com/Wolff09/plankton/blob/PLDI22/src/engine/solver/past.cpp" class="code-link"><code class="text-nowrap">src/engine/solver/past.cpp</code></a>
						</td>
						<td class=""> <!-- text-justify -->
							Implementation of history introduction and reasoning.
							Note that this implements the <em>how</em>.
							To see <em>when</em> this is performed, refer to <code class="text-nowrap">src/proof/common.hpp</code>.
						</td>
					</tr>
					<tr>
						<td scope="row">Futures</td>
						<td>
							<a target="new" href="https://github.com/Wolff09/plankton/blob/PLDI22/src/engine/solver/future.cpp" class="code-link"><code class="text-nowrap">src/engine/solver/future.cpp</code></a>
						</td>
						<td class=""> <!-- text-justify -->
							Implementation of future introduction and reasoning.
							Note that this implements the <em>how</em>.
							To see <em>when</em> this is performed, refer to <code class="text-nowrap">src/proof/common.hpp</code>.
						</td>
					</tr>
					<tr>
						<td scope="row">Interference</td>
						<td>
							<a target="new" href="https://github.com/Wolff09/plankton/blob/PLDI22/src/engine/solver/stability.cpp" class="code-link"><code class="text-nowrap">src/engine/solver/stability.cpp</code></a>
						</td>
						<td class=""> <!-- text-justify -->
							Applies interference (i.e. effects on the shared heap) such that annotations become stable (i.e. interference-free).
							Note that this implements the <em>how</em>.
							To see <em>when</em> this is performed, refer to <code class="text-nowrap">src/proof/common.hpp</code>.
						</td>
					</tr>
					<tr>
						<td scope="row">Join</td>
						<td>
							<a target="new" href="https://github.com/Wolff09/plankton/blob/PLDI22/src/engine/solver/join.cpp" class="code-link"><code class="text-nowrap">src/engine/solver/join.cpp</code></a>
						</td>
						<td class=""> <!-- text-justify -->
							Implementation of the join operation, which deals with now, past, and future predicates.
							Resource-like entities (variable bindings, points-to predicates, proof obligation resources) are matched manually; the remaining entities are handled semantically by encoding them into SMT.
						</td>
					</tr>
					<tr>
						<td scope="row">Entailment</td>
						<td>
							<a target="new" href="https://github.com/Wolff09/plankton/blob/PLDI22/src/engine/solver/implication.cpp" class="code-link"><code class="text-nowrap">src/engine/solver/implication.cpp</code></a>
						</td>
						<td class=""> <!-- text-justify -->
							Entailment operation, which deals with now, past, and future predicates.
							Resource-like entities (variable bindings, points-to predicates, proof obligation resources), futures, pasts are matched syntactically; only the now stack is handled semantically by encoding it into SMT.
						</td>
					</tr>
					<tr>
						<td scope="row">Encoding</td>
						<td>
							<a target="new" href="https://github.com/Wolff09/plankton/blob/PLDI22/include/engine/encoding.hpp" class="code-link"><code class="text-nowrap">include/engine/encoding.hpp</code></a>
							<br>
							<a target="new" href="https://github.com/Wolff09/plankton/blob/PLDI22/src/engine/encoding/" class="code-link"><code class="text-nowrap">src/engine/encoding/*</code></a>
						</td>
						<td class=""> <!-- text-justify -->
							SMT encoding of now predicates.
							The encoding does not handle resource-like entities (variable bindings, points-to predicates, proof obligation resources).
						</td>
					</tr>
					<tr>
						<td scope="row">Fixed Point</td>
						<td>
							<a target="new" href="https://github.com/Wolff09/plankton/blob/PLDI22/src/engine/proof/api.cpp" class="code-link"><code class="text-nowrap">src/engine/proof/api.cpp</code></a>
							<br>
							<a target="new" href="https://github.com/Wolff09/plankton/blob/PLDI22/src/engine/proof/common.cpp" class="code-link"><code class="text-nowrap">src/engine/proof/common.cpp</code></a>
						</td>
						<td class=""> <!-- text-justify -->
							Implements the fixed point (<code class="text-nowrap">src/engine/proof/api.cpp</code>) saturating the interference by repeatedly generating proofs for the API functions of the input program and extracting new inferferences from the generated proof.
							The generated proof is guaranteed to be interference-free: interferences are applied to the generated annotation unless a command is a right-mover (<code class="text-nowrap">src/engine/proof/common.cpp</code>).
							Past and future reasoning is applied whenever interference is applied or as a pre-processing step of the join operation (<code class="text-nowrap">src/engine/proof/common.cpp</code>).
						</td>
					</tr>
					<tr>
						<td scope="row">Linearizability</td>
						<td>
							<a target="new" href="https://github.com/Wolff09/plankton/blob/PLDI22/src/engine/proof/api.cpp" class="code-link"><code class="text-nowrap">src/engine/proof/api.cpp</code></a>
							<br>
							<a target="new" href="https://github.com/Wolff09/plankton/blob/PLDI22/src/engine/solver/post_assign_write.cpp" class="code-link"><code class="text-nowrap">src/engine/solver/post_assign_write.cpp</code></a>
							<br>
							<a target="new" href="https://github.com/Wolff09/plankton/blob/PLDI22/src/engine/solver/ful.cpp" class="code-link"><code class="text-nowrap">src/engine/solver/ful.cpp</code></a>
							<br>
							<a target="new" href="https://github.com/Wolff09/plankton/blob/PLDI22/src/engine/encoding/spec.cpp" class="code-link"><code class="text-nowrap">src/engine/encoding/spec.cpp</code></a>
						</td>
						<td class=""> <!-- text-justify -->
							Linearizability is checked for every proof generated for API function (<code class="text-nowrap">src/engine/proof/api.cpp</code>).
							The check is performed directly for impure memory assignment (<code class="text-nowrap">src/engine/solver/post_assign_write.cpp</code>) or using past (hindsight) reasoning (<code class="text-nowrap">src/engine/solver/fut.cpp</code>) on top of a function's proof (<code class="text-nowrap">src/engine/proof/api.cpp</code>).
							Whether or not the specification is met, is checked by encoding the keyset theorem in SMT (<code class="text-nowrap">src/engine/encoding/spec.cpp</code>).
						</td>
					</tr>
				</tbody>
			</table>
		</div>
		<br>



		<!-- ********************************************************************************** -->
		<!-- *********************************** REFERENCES *********************************** -->
		<!-- ********************************************************************************** -->
		<div id="references" class="mt-4">
			<h1><span class="index">&nbsp;</span> References</h1>
			<div class="ref-item" data-ref-full="Drachsler et al. 2018", data-ref-year="2014">
				<span class="ref-item-id">DrachslerVY14</span>
				<span class="ref-item-author">Dana Drachsler, Martin Vechev, and Eran Yahav. 2014.</span>
				<span class="ref-item-paper">Practical concurrent binary search trees via logical ordering.</span>
				<span class="ref-item-where">In PPoPP. ACM.</span>
				<a target="new" class="ref-item-url text-nowrap" href="https://doi.org/10.1145/2555243.2555269">https://doi.org/10.1145/2555243.2555269</a>
			</div>
			<div class="ref-item" data-ref-full="Feldman et al. 2018", data-ref-year="2018">
				<span class="ref-item-id">FeldmanEMRS18</span>
				<span class="ref-item-author">Yotam M. Y. Feldman, Constantin Enea, Adam Morrison, Noam Rinetzky, and Sharon Shoham. 2018.</span>
				<span class="ref-item-paper">Order out of Chaos: Proving Linearizability Using Local Views.</span>
				<span class="ref-item-where">In DISC (LIPIcs, Vol. 121). Springer.</span>
				<a target="new" class="ref-item-url text-nowrap" href="https://doi.org/10.4230/LIPIcs.DISC.2018.23">https://doi.org/10.4230/LIPIcs.DISC.2018.23</a>
			</div>
			<div class="ref-item" data-ref-full="Harris 2001", data-ref-year="2001">
				<span class="ref-item-id">Harris01</span>
				<span class="ref-item-author">Timothy L. Harris. 2001.</span>
				<span class="ref-item-paper">A Pragmatic Implementation of Non-blocking Linked-Lists.</span>
				<span class="ref-item-where">In DISC (LNCS, Vol. 2180). Springer.</span>
				<a target="new" class="ref-item-url text-nowrap" href="https://doi.org/10.1007/3-540-45414-4_21">https://doi.org/10.1007/3-540-45414-4_21</a>
			</div>
			<div class="ref-item" data-ref-full="Heller et al. 2005", data-ref-year="2005">
				<span class="ref-item-id">HellerHLMSS05</span>
				<span class="ref-item-author">Steve Heller, Maurice Herlihy, Victor Luchangco, Mark Moir, William N. Scherer III, and Nir Shavit. 2005.</span>
				<span class="ref-item-paper">A Lazy Concurrent List-Based Set Algorithm.</span>
				<span class="ref-item-where">In OPODIS (LNCS, Vol. 3974). Springer.</span>
				<a target="new" class="ref-item-url text-nowrap" href="https://doi.org/doi.org/10.1007/11795490_3">https://doi.org/10.1007/11795490_3</a>
			</div>
			<div class="ref-item" data-ref-full="Meyer et al. 2022", data-ref-year="2022">
				<span class="ref-item-id">MeyerWW22</span>
				<span class="ref-item-author">Roland Meyer, Thomas Wies, and Sebastian Wolff. 2022.</span>
				<span class="ref-item-paper">A concurrent program logic with a future and history.</span>
				<span class="ref-item-where">In OOPSLA. ACM.</span>
				<a target="new" class="ref-item-url text-nowrap" href="https://doi.org/10.1145/3563337">https://doi.org/10.1145/3563337</a>
			</div>
			<div class="ref-item" data-ref-full="Michael 2002", data-ref-year="2002">
				<span class="ref-item-id">Michael02</span>
				<span class="ref-item-author">Maged M. Michael. 2002.</span>
				<span class="ref-item-paper">High performance dynamic lock-free hash tables and list-based sets.</span>
				<span class="ref-item-where">In SPAA. ACM.</span>
				<a target="new" class="ref-item-url text-nowrap" href="https://doi.org/10.1145/564870.564881">https://doi.org/10.1145/564870.564881</a>
			</div>
			<div class="ref-item" data-ref-full="O'Hearn et al. 2010", data-ref-year="2010">
				<span class="ref-item-id">OHearnRVYY10</span>
				<span class="ref-item-author">Peter W. O’Hearn, Noam Rinetzky, Martin T. Vechev, Eran Yahav, and Greta Yorsh. 2010.</span>
				<span class="ref-item-paper">Verifying linearizability with hindsight.</span>
				<span class="ref-item-where">In PODC. ACM.</span>
				<a target="new" class="ref-item-url text-nowrap" href="https://doi.org/10.1145/1835698.1835722">https://doi.org/10.1145/1835698.1835722</a>
			</div>
			<div class="ref-item" data-ref-full="Herlihy and Shavit 2008", data-ref-year="2008">
				<span class="ref-item-id">HerlihyS08</span>
				<span class="ref-item-author">Maurice Herlihy and Nir Shavit. 2008.</span>
				<span class="ref-item-paper">The art of multiprocessor programming (Chapter 9.5).</span>
				<span class="ref-item-where">Morgan Kaufmann.</span>
				<a target="new" class="ref-item-url text-nowrap" href="https://isbnsearch.org/isbn/9780123705914">https://isbnsearch.org/isbn/9780123705914</a>
			</div>
			<div class="ref-item" data-ref-full="Vechev and Yahav 2008", data-ref-year="2008">
				<span class="ref-item-id">VechevY08</span>
				<span class="ref-item-author">Martin T. Vechev and Eran Yahav. 2008.</span>
				<span class="ref-item-paper">Deriving linearizable fine-grained concurrent objects.</span>
				<span class="ref-item-where">In PLDI. ACM.</span>
				<a target="new" class="ref-item-url text-nowrap" href="https://doi.org/10.1145/1375581.1375598">https://doi.org/10.1145/1375581.1375598</a>
			</div>
		</div>

		<br><br>
	</div>



	<!-- jQuery first, then Popper.js, then Bootstrap JS -->
	<script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49" crossorigin="anonymous"></script>
	<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js" integrity="sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy" crossorigin="anonymous"></script>

	<script type="text/javascript">
		var CITATION_MAP = { };
		function mk_link(authors, paper, where, url, linktext) {
			return '<a class="citation" target="new" data-toggle="tooltip" ' + 'title="' + authors + ' <i>' + paper + '</i> ' + where + '" href="' + url + '">' + linktext + '</a>';
		}
		$(".ref-item").each(function(){
			const ref_id = $(this).find(".ref-item-id").text();
			const ref_names = $(this).attr("data-ref-full");
			const ref_year = $(this).attr("data-ref-year");
			const ref_author = $(this).find(".ref-item-author").text();
			const ref_paper = $(this).find(".ref-item-paper").text();
			const ref_where = $(this).find(".ref-item-where").text();
			const ref_url = $(this).find(".ref-item-url").text();
			CITATION_MAP[ref_id] = [
				mk_link(ref_author, ref_paper, ref_where, ref_url, ref_names),
				mk_link(ref_author, ref_paper, ref_where, ref_url, ref_year),
			];
		});

		var all_found = true;
		$("span.ref-full, span.ref-year").each(function(){
			const ref_keys = $(this).text().split(",");
			const full = $(this).hasClass("ref-full") ? true : false;
			var citation = "";
			var first = true;
			for (index = 0, len = ref_keys.length; index < len; ++index) {
				const key = ref_keys[index].trim();
				var link;
				if (key in CITATION_MAP) {
					link = CITATION_MAP[key][full ? 0 : 1];
				} else {
					link = key;
					all_found = false;
				}
				if (!first) {
					citation += ", ";
				}
				first = false;
				citation += link;
			}
			$(this).html(citation);
		});
		if (all_found) {
			// $("#references").addClass("d-none");
			$(".ref-item").each(function(){
				const ref_names = $(this).attr("data-ref-full");
				$(this).find(".ref-item-id").text(ref_names);
			});
		}
	</script>
	<script type="text/javascript">
		$('[data-toggle="tooltip"]').tooltip({ 'html': true });
	</script>
</body>
</html>