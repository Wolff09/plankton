#name "Vechev DCAS Set EBR"
#spec "set"


struct Node {
	data_t val;
	Node* next;
}

// @contains(Node* node, data_t key) {
// 	return node->val == key;
// }

// @invariant(Node* node) {
// 	flow(node) != BOT => [MIN_VAL,node->val] <= flow(node)
// }


Node* Head;
Node* Tail;


void __init__() {
	Tail = malloc;
	Tail->next = NULL;
	Tail->val = MAX_VAL;
	Head = malloc;
	Head->next = Tail;
	Head->val = MIN_VAL;
}


inline <Node*, Node*, data_t> locate(data_t key) {
	Node* pred, curr;
	data_t k;

	curr = Head;
	do {
		pred = curr;
		curr = pred->next;

		if (curr == pred->next && curr != NULL) {
			k = curr->val;
		} else {
			curr = Head;
			k = MIN_VAL;
		}
	} while (k < key);
	return <pred, curr, k>;
}


bool add(data_t key) {
	Node* entry;

	entry = malloc;
	entry->val = key;

	while (true) {
		Node* pred, curr;
		data_t k;

		(pred, curr, k) = locate(key);

		if (k == key) {
			return false;

		} else {
			entry->next = curr;
			if (CAS(pred->next, curr, entry)) {
				return true;
			}
		}
	}
}


bool contains(data_t key) {
	Node* pred, curr;
	data_t k;

	(pred, curr, k) = locate(key);
	return k == key;
}


bool remove(data_t key) {
	while (true) {
		Node* pred, curr;
		data_t k;

		(pred, curr, k) = locate(key);

		if (k > key) {
			return false;

		} else {
			Node* next;

			next = curr->next;
			if (CAS((pred->next, curr->next), (curr, next), (next, NULL))) {
				return true;
			}
		}
	}
}
