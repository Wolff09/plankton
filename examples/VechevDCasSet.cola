#name "Vechev DCAS Set EBR"
#spec "set"


struct Node {
	data_t val;
	Node* next;
}

// @contains(Node* node, data_t key) {
// 	return node->val == key;
// }

// @invariant(Node* node) {
// 	flow(node) != BOT => [MIN_VAL,node->val] <= flow(node)
// }


Node* Head;
Node* Tail;


proc init() {
	Tail = malloc;
	Tail->next = NULL;
	Tail->val = MAX_VAL;
	Head = malloc;
	Head->next = Tail;
	Head->val = MIN_VAL;
}


macro locate(data_t key) returns (Node* pred, Node* curr, data_t k) {
	curr = Head;

	do {
		pred = curr;
		curr = pred->next;

		if (curr == pred->next && curr != NULL) {
			k = curr->val;
		} else {
			curr = Head;
			k = MIN_VAL;
		}
	} while (k < key);
}


proc contains(data_t key) returns (bool result) {
	Node* pred, curr;
	data_t k;

	(pred, curr, k) = locate(key);
	result = k == key;
}


proc add(data_t key) returns (bool result) {
	Node* entry;

	entry = malloc;
	entry->val = key;

	while (true) {
		Node* pred, curr;
		data_t k;

		(pred, curr, k) = locate(key);

		if (k == key) {
			result = false;
			return;

		} else {
			entry->next = curr;
			if (CAS(pred->next, curr, entry)) {
				result = true;
				return;
			}
		}
	}
}


proc remove(data_t key) returns (bool result) {
	Node* tmpNode;
	bool tmpBool;

	while (true) {
		Node* pred, curr, next;
		data_t k;

		(pred, curr, k) = locate(key);

		if (k > key) {
			result = false;
			return;

		} else {
			next = curr->next;
			if (CAS((pred->next, curr->next), (curr, next), (next, NULL))) {
				result = true;
				return;
			}
		}
	}
}
