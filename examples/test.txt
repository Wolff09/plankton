#name "LO-tree mod. WIP"


//*******************************************************//
//************************* API *************************//
//*******************************************************//

struct Node {
    thread_t treeLock;
    thread_t listLock;
    data_t key;
    Node* left;
    Node* right;
    Node* parent;
    Node* pred;
    Node* succ;
    bool mark;
}

Node* Min;
Node* Max;


bool contains(data_t k) {
    Node* y, foo;
    y = traverse(k);
    @join;

    while (k < y->key) {
        Node* x;
        x = y->pred;
        y = x;
    }
    while (y->mark) {
        Node* x;
        atomic {
            x = y->pred;
            assume(x->key < y->key); // ~~ use non-local invariant
        }
        y = x;
    }
    while (y->key < k) {
        Node* z;
        z = y->succ;
        y = z;
    }

    if (y->key == k) return true;
    else return false;
}


bool insert(data_t k) {
    Node* x, y, z, p;
    <x, z> = locate(k);
    
    assertFlow(k, z);
    if (z->key == k) {
        __unlock__(x->listLock);
        return false;
    }

    p = prepareTreeInsertion(x, z);
    y = malloc;
    y->key = k;
    y->mark = false;
    y->left = NULL;
    y->right = NULL;
    y->parent = p;
    y->pred = x;
    assert(x->key < y->key); // ~~ establish non-local invariant
    y->succ = z;
    assert(y->key < z->key); // ~~ establish non-local invariant
    // __lock__(y->treeLock);

    assertFlow(k, x);
    x->succ = y;
    assert(x->key < y->key); // ~~ establish non-local invariant
    z->pred = y;
    assert(y->key < z->key); // ~~ establish non-local invariant
    __unlock__(x->listLock);
    performTreeInsertion(y, p);
    return true;
}


bool remove(data_t k) {
    Node* x, y, z;
    <x, y> = locate(k);

    assertFlow(k, y);
    if (y->key != k) {
        __unlock__(x->listLock); // MISSING IN OUR PAPER!?
        return false;
    }

    __lock__(y->listLock);
    prepareTreeDeletion(y);
    atomic {
        z = y->succ;
        assume(y->key < z->key); // ~~ use non-local invariant
    }
    y->mark = true;
    z->pred = x;
    assert(x->key < z->key); // ~~ establish non-local invariant
    x->succ = z; // logical deletion
    assert(x->key < z->key); // ~~ establish non-local invariant
    __unlock__(y->listLock);
    __unlock__(x->listLock);
    performTreeDeletion(y);
    return true;
}


//*******************************************************//
//*********************** HELPERS ***********************//
//*******************************************************//

inline Node* traverse(data_t k) {
    Node* y;
    y = Max;
    while (true) {
        Node* c;
        if (y->key == k) return y;
        if (k < y->key) c = y->left;
        else c = y->right;
        if (c == NULL) return y;
        y = c;
    }
}


inline <Node*, Node*> locate(data_t k) {
    while (true) {
        Node* x, y, z;
        y = traverse(k);
        if (y->key < k) x = y;
        else x = y->pred;
        assume(x != Max); // ## TODO: invariante wird falsch Ã¼bersetzt! Min wird immer mit Knoten x belegt, was falsch ist!
        @join;
        assert(x != Max);
        __lock__(x->listLock);
        z = x->succ;
        if (x->key < k && k <= z->key && !x->mark) {
            return <x, z>;
        }
        __unlock__(x->listLock);
    }
}


// inline void lockWithHint(Node* ptr) {
//     atomic {
//         __lock__(ptr->lock);
//         __unlock__(ptr->lock);
//         choose { assume(ptr->mark == true); }{ assume(ptr->mark == false); }
//         __lock__(ptr->lock);
//     }
// }


//*******************************************************//
//********************** INVARIANT **********************//
//*******************************************************//

def @acyclicity { effective }

def @contains(Node* x, data_t k) { x->key == k }

def @outflow[left](Node* x, data_t k) { false }
def @outflow[right](Node* x, data_t k) { false }
def @outflow[parent](Node* x, data_t k) { false }
def @outflow[pred](Node* x, data_t k) { false }
def @outflow[succ](Node* x, data_t k) { x->key < k }

def @invariant[local](Node* x) {
    x->_flow == 0
}

def @invariant[shared](Node* x) {
    // Min
    Min != NULL
 && Min->key == MIN
 && Min->mark == false
 && Min->succ != NULL
 && x->key == MIN ==> x == Min
 && [MIN, MAX] in Min->_flow
    // Max
 && Max != NULL
 && Max->key == MAX
 && Max->mark == false
 && Max->pred != NULL
 && x->key == MAX ==> x == Max
    // flow
 && x->_flow != 0 ==> [x->key, MAX] in x->_flow
 && !x->mark ==> x->_flow != 0
    // structure
 && x->key != MAX ==> x->succ != NULL
 && x->key != MIN ==> x->pred != NULL
    //
    //
    // wip
 // && Min->pred == NULL
 // && Max->succ == NULL
 // && x->succ != NULL ==> x->key != MAX
 // && x->pred != NULL ==> x->key != MIN
 //
 // && Min != x->succ // TODO: the encoding of this is wrong!!
 // && Max != x->pred // TODO: the encoding of this is wrong!!
 // && x->key != MIN && x->key != MAX ==> x->parent != NULL
 // && x->parent != NULL ==> x->key != MIN && x->key != MAX
 // && MIN < x->key && x->key < MAX ==> x->parent != NULL
    // non-local
 // && (!x->mark && x->lock == UNLOCKED) ==> "succ not marked"
 // && (x->_flow != 0) ==> "pred flow not empty
}


//*******************************************************//
//************************ INIT *************************//
//*******************************************************//

void __init__() {
    Max = malloc;
    Min = malloc;
    Min->key = MAX;
    Min->left = NULL;
    Min->right = NULL;
    Min->parent = NULL;
    Min->pred = NULL;
    Min->succ = Max;
    Min->mark = false;
    Max->key = MIN;
    Max->left = NULL;
    Max->right = NULL;
    Max->parent = NULL;
    Max->pred = Min;
    Max->succ = NULL;
    Max->mark = false;
}


//*******************************************************//
//********************* TREE STUBS **********************//
//*******************************************************//

inline Node* prepareTreeInsertion(Node* x, Node* z) {
    @stub Node::treeLock;
    choose{ return x; }{ return z; }
}

inline void performTreeInsertion(Node* y, Node* p) {
    @stub Node::left;
    @stub Node::right;
    @stub Node::parent;
    @stub Node::treeLock;
}


inline void prepareTreeDeletion(Node* y) {
    @stub Node::treeLock;
}

inline void performTreeDeletion(Node* y) {
    @stub Node::left;
    @stub Node::right;
    @stub Node::parent;
    @stub Node::treeLock;
}
