#name "Lazy Skip List for Height 2"


struct Node {
    thread_t lock;
	data_t val;
	Node* next1;
	Node* next2;
	bool marked;
	bool linked;
	bool topLevel;
}

Node* Head;
Node* Tail;


inline <Node*, Node*, Node*, Node*, data_t, data_t> locate(data_t key) {
	Node* pred1, pred2, curr1, curr2, node;
	data_t k1, k2;

	curr2 = Head;
	do {
		pred2 = curr2;
		curr2 = pred2->next2;
		k2 = curr2->key;
	} while (key > k2)

	curr1 = Head;
	do {
		pred1 = curr1;
		curr1 = pred1->next1;
		k1 = curr1->key;
	} while (key > k1)

	return <pred1, pred2, curr1, curr2, k1, k2>;
}


bool contains(data_t key) {
	Node* pred1, pred2, succ1, succ2, entry;
	data_t k1, k2;

	<pred1, pred2, succ1, succ2, k1, k2> = locate(key);
	if (k2 == key && succ2->linked && !succ2.marked) return true;
	else if (k1 == key && succ1->linked && !succ1.marked) return true;
	else return false;
}


bool add(data_t key) {
	Node* pred1, pred2, succ1, succ2, entry;
	data_t k1, k2;

	entry = malloc;
	entry->val = key;
	entry->marked = false;
	entry->linked = false;

	while (true) {
		<pred1, pred2, succ1, succ2, k1, k2> = locate(key);

		// found at level 2
		if (key == k2) {
			if (!succ2->marked) {
				while (!succ2.linked) {}
				return false;
			}
		}

		// found at level 1
		else if (key == k1) {
			if (!succ1->marked) {
				while (!succ1.linked) {}
				return false;
			}
		}

		// not found ~> inserting
		else {
			choose {
				// topLevel = false
				__lock__(pred1->lock);
				if (!pred1->marked && !succ1->marked && pred1->next1 == succ1) {
					entry.topLevel = false;
					entry.next1 = succ1;
					entry.next2 = NULL;
					pred1.next1 = entry;
					entry.linked = true;
					__unlock__(pred1->lock);
					return true;
				}

			}{
				// topLevel = true
				__lock__(pred1->lock);
				if (!pred1->marked && !succ1->marked && pred1->next1 == succ1) {
					if (pred1 != pred2) __lock__(pred2->lock);
					if (!pred2->marked && !succ2->marked && pred2->next2 == succ2) {
						entry.topLevel = false;
						entry.next1 = succ1;
						entry.next2 = succ2;
						pred1.next1 = entry;
						pred2.next2 = entry;
						entry.linked = true;
						__unlock__(pred1->lock);
						if (pred1 != pred2) __unlock__(pred2->lock);
						return true;
					}
				}
			}
		}
	}
}


bool remove(data_t key) {
	Node* pred1, pred2, succ1, succ2, victim;
	data_t k1, k2, isMarked, found, foundTopLevel, topLevel;

	isMarked = false;
	topLevel = false;
	victim = NULL;

	while (true) {
		found = false;
		<pred1, pred2, succ1, succ2, k1, k2> = locate(key);
		if (k2 == key) { victim = succ2; found = true; foundTopLevel = true; }
		else if (k1 == key) { victim = succ1; found = true; foundTopLevel = false; }

		if (isMarked || (found && victim->linked && victim->topLevel == foundTopLevel && !victim->marked)) {
			// logical deletion
			if (!isMarked) {
				topLevel = victim.topLevel;
				__lock__(victim->lock);
				if (victim->marked) {
					__unlock__(victim->lock);
					return false;
				} else {
					victim->marked = true;
					isMarked = true;
				}
			}

			// physical deletion for 1 level
			if (topLevel) {
				__lock__(pred1->lock);
				if (!pred1->marked && pred1->next1 == victim) {
					pred1->next1 = victim->next1;
					__unlock__(victim->lock);
					__unlock__(pred1->lock);
					return true;
				}

			// physical deletion for 2 levels
			} else {
				__lock__(pred1->lock);
				if (!pred1->marked && pred1->next1 == victim) {
					if (pred1 != pred2) __lock__(pred2->lock);
					if (!pred2->marked && pred2->next2 == victim) {
						pred1->next1 = victim->next1;
						pred2->next2 = victim->next2;
						__unlock__(victim->lock);
						__unlock__(pred1->lock);
						if (pred1 != pred2) __unlock__(pred2->lock);
						return true;
					}
				}
			}

		} else return false;
	}
}
