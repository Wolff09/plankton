struct Node {
    Node next;
    data_t val;
};

Node* Head;
Node* Tail;

void __init__() {
    Tail = malloc;
    Tail->next = NULL; // 10
    Tail->val = MAX_VAL; // 14
    Head = malloc;
    Head->next = Tail; // 19
    Head->val = MIN_VAL; // 23
}

inline <Node*, Node*, data_t> locate(data_t _key) {
    Node* _pred;
    Node* _curr;
    data_t _k;

    _curr = Head; // 39
    do {
        _pred = _curr; // 45
        _curr = _pred->next; // 49
        choose {
            assume(_curr == _pred->next && _curr != NULL); // 284
            _k = _curr->val; // 61
        }{
            assume(_curr != _pred->next || _curr == NULL); // 282
            _curr = Head; // 65
            _k = MIN_VAL; // 68
        }
        choose {
            assume(_k >= _key); // 292
            break;
        }{
            assume(_k < _key); // 290
            skip;
        }
    } while (true);
    return <_pred, _curr, _k>;
}

bool remove(data_t key) {
    while (true) {
        Node* pred;
        Node* curr;
        data_t k;

        <pred, curr, k> = locate(key);
        choose {
            assume(k > key); // 300
            return false;
        }{
            Node* next;

            assume(k <= key); // 298
            next = curr->next; // 106
            choose {
                atomic {
                    assume(pred->next == curr && curr->next == next); // 236
                    pred->next = next; // 220
                    curr->next = NULL; // 224
                }
                return true;
            }{
                assume(pred->next != curr || curr->next != next); // 235
                skip;
            }
        }
    }
}

bool add(data_t key) {
    Node* entry;

    entry = malloc;
    entry->val = key; // 138
    while (true) {
        Node* pred;
        Node* curr;
        data_t k;

        <pred, curr, k> = locate(key);
        choose {
            assume(k == key); // 308
            return false;
        }{
            assume(k != key); // 306
            entry->next = curr; // 157
            choose {
                atomic {
                    assume(pred->next == curr); // 258
                    pred->next = entry; // 252
                }
                return true;
            }{
                assume(pred->next != curr); // 257
                skip;
            }
        }
    }
}

bool contains(data_t key) {
    Node* pred;
    Node* curr;
    data_t k;

    <pred, curr, k> = locate(key);
    choose {
        assume(k == key); // 316
        return true;
    }{
        assume(k != key); // 314
        return false;
    }
}