struct Node {
    Node next;
    data_t val;
};

Node* Head;
Node* Tail;

void __init__() {
    Tail = malloc;
    Tail->next = NULL; // 10
    Tail->val = MAX_VAL; // 14
    Head = malloc;
    Head->next = Tail; // 19
    Head->val = MIN_VAL; // 23
}

inline <Node*, Node*, data_t> locate(data_t _key) {
    Node* _pred;
    Node* _curr;
    data_t _k;

    _curr = Head; // 39
    do {
        _pred = _curr; // 45
        _curr = _pred->next; // 49
        choose {
            assume(_curr == _pred->next && _curr != NULL); // 312
            _k = _curr->val; // 61
        }{
            assume(_curr != _pred->next || _curr == NULL); // 310
            _curr = Head; // 65
            _k = MIN_VAL; // 68
        }
        choose {
            assume(_k >= _key); // 320
            break;
        }{
            assume(_k < _key); // 318
            skip;
        }
    } while (true);
    return <_pred, _curr, _k>;
}

bool contains(data_t key) {
    Node* pred;
    Node* curr;
    data_t k;

    <pred, curr, k> = locate(key);
    choose {
        assume(k == key); // 328
        return true;
    }{
        assume(k != key); // 326
        return true;
    }
}

bool add(data_t key) {
    Node* entry;

    entry = malloc;
    entry->val = key; // 110
    while (true) {
        Node* pred;
        Node* curr;
        data_t k;

        <pred, curr, k> = locate(key);
        choose {
            assume(k == key); // 348
            choose {
                assume(false); // 334
                return true;
            }{
                assume(true); // 332
                return true;
            }
        }{
            assume(k != key); // 346
            entry->next = curr; // 129
            choose {
                atomic {
                    assume(pred->next == curr); // 221
                    pred->next = entry; // 215
                }
                choose {
                    assume(true); // 340
                    return true;
                }{
                    assume(false); // 338
                    return true;
                }
            }{
                assume(pred->next != curr); // 220
                skip;
            }
        }
    }
}

bool remove(data_t key) {
    while (true) {
        Node* pred;
        Node* curr;
        data_t k;

        <pred, curr, k> = locate(key);
        choose {
            assume(k > key); // 368
            choose {
                assume(false); // 354
                return true;
            }{
                assume(true); // 352
                return true;
            }
        }{
            Node* next;

            assume(k <= key); // 366
            next = curr->next; // 173
            choose {
                atomic {
                    assume(pred->next == curr && curr->next == next); // 258
                    pred->next = next; // 242
                    curr->next = NULL; // 246
                }
                choose {
                    assume(true); // 360
                    return true;
                }{
                    assume(false); // 358
                    return true;
                }
            }{
                assume(pred->next != curr || curr->next != next); // 257
                skip;
            }
        }
    }
}

//
// END program "Vechev DCAS Set EBR (preprocessed)"
//
libc++abi.dylib: terminating with uncaught exception of type std::logic_error: breakpoint

Process finished with exit code 134 (interrupted by signal 6: SIGABRT)
