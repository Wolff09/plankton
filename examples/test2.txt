#name "LO-tree WIP"


struct Node {
    thread_t treeLock;
    thread_t listLock;
	data_t key;
	Node* left;
    Node* right;
    Node* parent;
    Node* pred;
	Node* succ;
    bool mark;
}

Node* Min;
Node* Max;


def @acyclicity { effective }

def @contains(Node* x, data_t k) {
    !x->mark && x->key == k
}

def @outflow[left](Node* x, data_t k) {
    false
}

def @outflow[right](Node* x, data_t k) {
    false
}

def @outflow[parent](Node* x, data_t k) {
    false
}

def @outflow[pred](Node* x, data_t k) {
    false
}

def @outflow[succ](Node* x, data_t k) {
    x->key < k
}

def @invariant[local](Node* x) {
    x->_flow == 0
}

def @invariant[shared](Node* x) {
    // Min
    Min != NULL
 && Min->key == MIN
 && Min->mark == false
 && Min->succ != NULL
 // && Min->pred == NULL
 && x->key == MIN ==> x == Min
 && [MIN, MAX] in Min->_flow
    // Max
 && Max != NULL
 && Max->key == MAX
 && Max->mark == false
 // && Max->succ == NULL
 && Max->pred != NULL
 && x->key == MAX ==> x == Max
    // flow
 && x->_flow != 0 ==> [x->key, MAX] in x->_flow
 && !x->mark ==> x->_flow != 0
    // structure
 && x->key != MAX ==> x->succ != NULL
 && x->key != MIN ==> x->pred != NULL
 // && x->succ != NULL ==> x->key != MAX
 // && x->pred != NULL ==> x->key != MIN
    //
    //
    // wip
 // && Min != x->succ // TODO: the encoding of this is wrong!!
 // && Max != x->pred // TODO: the encoding of this is wrong!!
 // && x->key != MIN && x->key != MAX ==> x->parent != NULL
 // && x->parent != NULL ==> x->key != MIN && x->key != MAX
 // && MIN < x->key && x->key < MAX ==> x->parent != NULL
    // non-local
 // && (!x->mark && x->lock == UNLOCKED) ==> "succ not marked"
 // && (x->_flow != 0) ==> "pred flow not empty
}


void __init__() {
    Max = malloc;
    Min = malloc;
    Min->key = MAX;
    Min->left = NULL;
    Min->right = NULL;
    Min->parent = NULL;
    Min->pred = NULL;
    Min->succ = Max;
    Min->mark = false;
    Max->key = MIN;
    Max->left = NULL;
    Max->right = NULL;
    Max->parent = NULL;
    Max->pred = Min;
    Max->succ = NULL;
    Max->mark = false;
}


inline Node* traverse(data_t k) {
    Node* y;
    y = Max;
    while (true) {
        Node* c;
        if (y->key == k) return y;
        if (k < y->key) c = y->left;
        else c = y->right;
        if (c == NULL) return y;
        y = c;
    }
}


// inline void lockWithHint(Node* ptr) {
//     atomic {
//         __lock__(ptr->lock);
//         __unlock__(ptr->lock);
//         choose { assume(ptr->mark == true); }{ assume(ptr->mark == false); }
//         __lock__(ptr->lock);
//     }
// }


inline <Node*, Node*> locate(data_t k) {
    while (true) {
        Node* x, y, z;
        y = traverse(k);
        if (y->key < k) x = y;
        else x = y->pred;
        // assert(x != Max);
        assume(x != Max); // TODO: invariante wird falsch Ã¼bersetzt! Min wird immer mit Knoten x belegt, was falsch ist!
        __lock__(x->listLock);
        z = x->succ;
        choose { // if (x->key < k && k <= z->key && !x->mark)
            assume(x->key < k && k <= z->key && !x->mark);
            assume(!z->mark); // ~~ assume non-local invariant "!x->mark && unlocked(x) => !x->succ->mark"
            return <x, z>;
        }{
            skip; // simplified else branch
        }
        __unlock__(x->listLock);
    }
}


bool contains(data_t k) {
    Node* y;
    y = traverse(k);
    while (y->mark) {
        Node* x;
        x = y->pred;
        y = x;
    }
    // assertFlow(MAX, y);
    while (k < y->key) {
        Node* x;
        atomic {
            x = y->pred;
            assumeFlow(MAX, x); // ~~ assume non-local invariant "x->flow != 0 ==> x->pred->flow != 0"
        }
        y = x;
    }
    // assertFlow(k, y);
    while (y->key < k) {
        Node* z;
        z = y->succ;
        y = z;
    }
    if (y->key == k && !y->mark) return true;
    else return false;
}


inline Node* prepareTreeInsertion(Node* x, Node* z) {
    // choose {
    //     __lock__(x->treeLock);
    //     assume(x->right == NULL);
    //     return x;
    // }{
    //     __lock__(z->treeLock);
    //     assume(z->left == NULL);
    //     return z;
    // }
    Node* p;
    assume(p == x || p == z);
    return p;

    // @updates Node::treeLock;
    // Node* p;
    // return p;
}

inline void performTreeInsertion(Node* y, Node* p) {
    // if (p->key < y->key) {
    //     assert(p->right == NULL);
    //     p->right = y;
    // } else {
    //     assert(p->left == NULL);
    //     p->left = y;
    // }
    // __unlock__(p->treeLock);
    // __unlock__(y->treeLock);
    choose {
        p->right = y;
    }{
        p->left = y;
    }

    // @updates Node::left;
    // @updates Node::right;
    // @updates Node::treeLock;
}


bool insert(data_t k) {
    Node* x, y, z, p;
    <x, z> = locate(k);
    // assertFlow(k, x);
    // assertFlow(k, z);
    if (z->key == k) {
        __unlock__(x->listLock);
        return false;
    }
    p = prepareTreeInsertion(x, z);
    y = malloc;
    y->key = k;
    y->mark = false;
    y->left = NULL;
    y->right = NULL;
    y->parent = p;
    y->pred = x;
    atomic {
        y->succ = z;
        assert(!z->mark); // ~~ ensure non-local invariant "!x->mark && unlocked(x) => !x->succ->mark"
    }
    // __lock__(y->treeLock);

    atomic {
        assert(x != y && y != z && x != z); // ~~
        assertFlow(MAX, x); // ~~
        assertFlow(MAX, z); // ~~
        x->succ = y;
        assert(y->pred == x); // ~~ 
        assertFlow(MAX, x); // ~~ ensure non-local invariant "x->flow != 0 ==> x->pred->flow != 0"
        assertFlow(MAX, y); // ~~
        assertFlow(MAX, z); // ~~
    }
    z->pred = y;
    atomic{
        __unlock__(x->listLock);
        assert(!y->mark); // ~~ ensure non-local invariant "!x->mark && unlocked(x) => !x->succ->mark"
    }
    performTreeInsertion(y, p);
    return true;
}


inline void prepareTreeDeletion(Node* y) {
    skip;
    // @updates Node::treeLock;
}

inline void performTreeDeletion(Node* y) {
    choose {
        // y has less than two children
        Node* p, c;
        p = y->parent;
        assume(p != NULL); // adding structual tree invariant
        choose {
            c = y->left;
        }{
            c = y->right;
        }
        choose {
            p->left = c;
        }{
            p->right = c;
        }
        if (c != NULL) c->parent = p;
    }{
        // y has two children
        Node* yp, yl, yr, s, sp, sc;
        yp = y->parent;
        assume(yp != NULL); // adding structual tree invariant
        yl = y->left;
        yr = y->right;
        s = y->succ;
        assume(s != Max); // adding structural tree-list invariant
        sp = s->parent;
        assume(sp != NULL); // adding structual tree invariant
        sc = s->right;
        sp->left = sc;
        if (sc != NULL) sc->parent = sp;
        s->left = yl;
        s->right = yr;
        choose {
            yp->left = s;
        }{
            yp->right = s;
        }
        s->parent = yp;
    }

    // @updates Node::left;
    // @updates Node::right;
    // @updates Node::parent;
    // @updates Node::treeLock;
}


bool remove(data_t k) {
    Node* x, y, z;
    <x, y> = locate(k);
    if (y->key != k) {
        __unlock__(x->listLock); // MISSING IN OUR PAPER!?
        return false;
    }
    __lock__(y->listLock);
    prepareTreeDeletion(y);
    z = y->succ;
    atomic {
        assert(!y->mark); // ~~
        assume(!z->mark); // ~~ assume non-local invariant "!x->mark && unlocked(x) => !x->succ->mark"
    }
    atomic {
        assert(!x->mark && !z->mark); // ~~
        assert(x != y && y != z && x != z); // ~~
        assertFlow(MAX, x); // ~~
        assertFlow(MAX, y); // ~~
        assertFlow(MAX, z); // ~~
    }
    y->mark = true;
    z->pred = x;
    atomic {
        x->succ = z;
        assert(!x->mark && !z->mark); // ~~
        assert(x != y && y != z && x != z); // ~~
        assertFlow(MAX, x); // ~~
        // ~~ TODO: assert y has no flow
        assertFlow(MAX, z); // ~~
    }
    __unlock__(y->listLock);
    __unlock__(x->listLock);
    performTreeDeletion(y);
    return true;
}
